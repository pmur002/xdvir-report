<?xml version="1.0" encoding="UTF-8"?>
<html>
  <head>
    <title>LaTeX Typesetting in R</title>
    <style type="text/css">
    @media print {
      body { }
      p.img { text-align: center; page-break-inside: avoid }
      img.CC { display: inline }
    }
    @media screen {
      body { max-width: 800px; margin: auto }
      p.img { text-align: center }
      img.CC { display: inline }
    }
    p.date {
      font-size: smaller;
      margin: 0;
    }
    p.versionHistory {
      color: gray
    }
    p.versionHistory a {
      color: gray
    }
    p.ref {
      text-indent: -2em;
      padding-left: 2em;
    }
    p.fig {
      text-align: left;
    }
    p.fig img, img.plot {
      box-shadow: 10px 10px 20px;
      margin-top: 10px;
      margin-bottom: 20px;      
    }
  </style>
    <script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
  </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>
  </head>
  <body>
    <h1>TeX Typesetting in R: The 'xdvir' Package</h1>
    <p>
      <span style="font-style: italic">by Paul Murrell</span>
      <a href="http://orcid.org">
        <img alt="" src="https://www.stat.auckland.ac.nz/~paul/ORCID/ORCiD.png" style="width: 16px; height: 16px; vertical-align: middle"/>
      </a>
      <span style="font-family: mono; font-size: small">
        <a href="http://orcid.org/0000-0002-3224-8858">http://orcid.org/0000-0002-3224-8858</a>
      </span>
    </p>
    <p class="date">
    Version 1:  
    <rcode echo="FALSE" results="asis"><![CDATA[
cat(format(Sys.Date(), "%A %d %B %Y"))
    ]]></rcode>
  </p>
    <rcode id="init" echo="FALSE" message="FALSE" results="hide"><![CDATA[
opts_chunk$set(comment=" ", tidy=FALSE, 
               dev="png", ## dev="svg",
               dpi=96)
options(width=100)
## For wonky desktop set up
options(bitmapType="cairo")
  ]]></rcode>
    <rcode echo="FALSE" message="FALSE"><![CDATA[
    library(grid)
  ]]></rcode>
    <hr/>
    <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="CC" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
    <hr/>
    <p>
    This document describes the 'xdvir' package
  </p>
    <div>
      <h2>Table of Contents:</h2>
      <ul style="list-style: none">
        <li>
          <a href="#intro">1. Introduction</a>
        </li>
        <li>
          <a href="#author">2. Authoring</a>
        </li>
        <li>
          <a href="#typeset">3. Typesetting</a>
        </li>
        <li>
          <a href="#render">4. Rendering</a>
        </li>
        <li>
          <a href="#packages">5. Packages</a>
        </li>
        <li>
          <a href="#engines">6. Engines</a>
        </li>
        <li>
          <a href="#fontlibs">7. Font libraries</a>
        </li>
        <li>
          <a href="#requirements">8. Technical requirements</a>
        </li>
        <li>
          <a href="#Resources">9. Resources</a>
        </li>
        <li>
          <a href="#references">10. References</a>
        </li>
      </ul>
    </div>
    <h2>
      <a name="intro">1. Introduction</a>
    </h2>
    <p>
    The 'xdvir' package for R 
    (<a href="#xdvir-pkg"/>) 
    allows LaTeX fragments to be used as
    labels and annotations on R plots.  The 
    package vignette describes basic high-level usage 
    and an article submitted to the R Journal
    explains more and has more complex examples.
    The purpose of this document is to provide a description
    of some more advanced uses of the package, including ways to
    extend the package, and to provide a record of the 
    lower-level design and implementation of the package.
  </p>
    <p>
    The package startup detects and reports on which TeX engines are available
    on the current system.  This report is built on a system
    with XeTeX and an acceptable version of LuaTeX, so both of those
    engines are available.  This means that the default engine
    for building this report is LuaTeX.
  </p>
    <rcode><![CDATA[
library(xdvir)
  ]]></rcode>
    <rcode><![CDATA[
    getOption("xdvir.engine")$name
  ]]></rcode>
    <p>
    Rendering a LaTeX fragment in R involves three steps:
  </p>
    <ol>
      <li><strong>Authoring:</strong> The LaTeX fragment has to be augmented
      to create a complete LaTeX document.
    </li>
      <li><strong>Typesetting:</strong> The LaTeX document has to be typeset to
      create a file of DVI operations and that DVI file has to be
      read into an R data structure.
    </li>
      <li><strong>Rendering:</strong> The DVI data structure has to be drawn.
    </li>
    </ol>
    <p>
      <img src="diagram/diag.png" alt="The high-level design of the xdvir package." style="max-width: 100%"/>
    </p>
    <p>
    This document begins by taking a closer look at each of those three steps.
  </p>
    <h2>
      <a name="author">2. Authoring</a>
    </h2>
    <p>
    The <code>author()</code> function turns a LaTeX fragment into 
    a LaTeX document.  This consists of adding additional
    LaTeX code around the LaTeX fragment.
  </p>
    <rcode><![CDATA[
fragment <- "test"
author(fragment)
  ]]></rcode>
    <p>
    There are some obvious additions, like <code>\begin{document}</code> and
    <code>\end{document}</code>.  
  </p>
    <p>
    The <code>\documentclass</code> is always
    <code>standalone</code>.  This is partly because that seems sensible - the
    LaTeX fragments are not complete documents, but typically small labels to be
    added to other drawing - but also because that will not produce, for
    example, any page numbering or headers and footers that you normally
    get from something like the standard <code>article</code> class.
  </p>
    <p>
    The <code>varwidth</code> option is set for the <code>standalone</code>
    class.  This is not always necessary and it may actually cause
    problems if the width of the DVI output exceeds the text width of 
    a standard article.  However, the <code>width</code> argument
    to <code>author()</code> can be used to specify an explicit width
    if that is convenient and/or if that is necessary.
    This uses the <code>varwidth</code> option to set an explicit width.
    If given, the <code>width</code> is interpreted as a number of inches.
  </p>
    <rcode><![CDATA[
author(fragment, width=2)    
  ]]></rcode>
    <p>
    The <code>\usepackage{unicode-math}</code> is there to force the TeX engine
    to use TrueType math fonts and to produce font file paths in DVI output.
    Without this, you tend to get <code>fnt_def</code> operations in the DVI
    output of the form <code>cmmi10</code>.  Those not only require mapping to
    actual font files, but they resolve to Type 1 fonts.  That is a problem
    because the rendering of LaTeX fragments requires a graphics device that has
    support for rendering glyphs
    <a href="murrell-pedersen-urbanek-glyphs-2023"/>
    and the main set of those is the Cairo devices and they 
    no longer support Type 1 fonts.
  </p>
    <p>
    The comment on the first line records information about the version of
    'xdvir', the TeX engine that was used to author the document, and the LaTeX
    packages that were specified.  As noted previously, the engine defaults on
    package startup.  This information is used in the typesetting step
    to check that compatible TeX engines and packages are used in different
    steps.
  </p>
    <p>
    We can use the <code>engine</code> and
    <code>packages</code> arguments to <code>author()</code> to explicitly set
    those values.  Notice that the addition of <code>packages="xcolor"</code>
    adds to both the comment on the first line and a new
    <code>\usepackage</code> line.  
  </p>
    <rcode><![CDATA[
author(fragment, engine="xetex", packages="xcolor")    
  ]]></rcode>
    <p>
    Some packages will add more lines.  For example, the <code>preview</code>
    package adds further to the document preamble and wraps the fragment
    within a <code>preview</code> environment.  
  </p>
    <rcode><![CDATA[
author(fragment, packages="preview")    
  ]]></rcode>
    <p>
    Functions like <code>grid.latex()</code> and <code>geom_latex()</code>
    also add additional code to LaTeX fragments in order to 
    match the current font family, font face, and font size.
    We can easily see this if we use the <code>texFile</code> argument
    to control the name of the file that 'xdvir' writes a full LaTeX
    document into.
    For example, the following code draws a simple LaTeX fragment
    and automatically matches the R default font family (rather than
    using the default LaTeX Computer Modern font).
    This is implemented by adding <code>\setmainfont</code> and
    <code>\fontsize</code> commands to the LaTeX document 
    (plus <code>\usepackage{fontspec}</code>).
  </p>
    <rcode fig.width="1" fig.height=".5"><![CDATA[
grid.latex(fragment, texFile="test.tex")
cat(readLines("test.tex"), sep="\n")
  ]]></rcode>
    <p>
    Where user-level functions add a lot
    of additional code to the LaTeX fragment, like the examples above, 
    there is a risk of 
    conflicting with the LaTeX fragment and/or a risk of 
    packages conflicting with each other.  This is one possible
    reason for authoring a LaTeX document directly rather than relying
    on the <code>author()</code> function.
    However, care must be taken in that case to retain features like
    <code>\usepackage{unicode-math}</code> so that the right 
    DVI output is produced during the typesetting step.
  </p>
    <p>
    In other words, here be dragons.  On the positive side, I have yet
    to irretrievably bite myself with this problem.
  </p>
    <p>
    We will talk more about engines and packages later on.
  </p>
    <h2>
      <a name="typeset">3. Typesetting</a>
    </h2>
    <p>
    The <code>typeset()</code> function processes a LaTeX document
    to a <code>"DVI"</code> object.
    The LaTeX document can be a <code>"LaTeXdocument"</code>
    object, as produced by <code>author()</code>
    or just a character vector (though the latter must be a complete
    LaTeX document, not just a LaTeX fragment).
  </p>
    <rcode><![CDATA[
doc <- author(fragment)
dvi <- typeset(doc)
dvi
  ]]></rcode>
    <p>
    The <code>typeset()</code> function generates a DVI file by 
    writing the LaTeX document to a file and running a TeX engine
    to produce a DVI file.
    'xdvir' makes use of <code>latexmk()</code> from the 'tinytex'
    package for this step, which automatically takes care of 
    multiple runs of the TeX engine and even installing missing 
    LaTeX packages in at least some cases.
  </p>
    <p>
    The <code>"DVI"</code> object has a print method to show the contents
    of a DVI file in a human-readable format.
    Underneath, it is a list of <code>"rawFormat"</code>
    objects from the 'hexView' package;  labelled blocks of 
    raw bytes along with interpreted values (integers, strings, etc).
  </p>
    <rcode><![CDATA[
dvi[[1]]
  ]]></rcode>
    <p>
    Notice that <code>typeset()</code> embeds a "signature" in
    the <code>pre</code> operation of the DVI file that records 
    information about the 'xdvir' version, the TeX engine used,
    and any LaTeX packages used.  This information is used in the
    rendering step 
    to check that compatible TeX engines and packages are used in different
    steps.
  </p>
    <p>
    There is an <code>engine</code> argument to allow the TeX engine
    to be specified, but it will default from information in the
    LaTeX document if that exists.
  </p>
    <h3>Debugging</h3>
    <p>    
    The typesetting step is probably where most user problems will occur, 
    most probably because the LaTeX fragment (or the LaTeX
    document) contains an error, so the call to a TeX engine fails.
  </p>
    <rcode><![CDATA[
bugFrag <- paste(fragment, "$")
docBug <- author(bugFrag)
typeset(docBug)
  ]]></rcode>
    <p>
    The <code>texFile</code> argument is useful in cases like this because
    the <code>.log</code> file will be in the same location as the
    <code>texFile</code>, so we can easily see what the problem is.
    Using <code>texFile</code> is also a good way to
    easily get hold of the LaTeX document and run a TeX engine on it
    outside of R to debug the problem.
  </p>
    <h3>Caching</h3>
    <p>
    'xdvir' automatically caches typsetting results. If the combination of
    LaTeX document, TeX engine, and LaTeX packages has been seen before
    then a cached <code>"DVI"</code> object will be used.
  </p>
    <p>
    For debugging problems, it can be useful to turn off caching 
    with <code>options(xdvir.useDVIcache=FALSE)</code>.
  </p>
    <h3>Manual typesetting</h3>
    <p>
    Because <code>typeset()</code> accepts a simple character vector,
    it is easy to author a LaTeX document outside of R and
    just <code>readLines()</code> that document to pass it to 
    <code>typeset</code>.
  </p>
    <rcode><![CDATA[
doc <- readLines("test.tex")
dvi <- typeset(doc)
  ]]></rcode>
    <p>
    It is also possible to perform the typesetting outside of R and
    just read a DVI file in using <code>readDVI()</code>.
    The important thing here is to make sure that you produce a DVI file.
    (The funny-looking construction of the <code>command</code>
    below is just to avoid 'knitr' errors.)
  </p>
    <rcode><![CDATA[
arg <- "-no-pdf"
command <- sprintf("xelatex -%s test.tex", arg)
system(command)
dvi <- readDVI("test.xdv")
  ]]></rcode>
    <h2>
      <a name="render">4. Rendering</a>
    </h2>
    <p>
    The <code>render()</code> function renders a <code>"DVI"</code>
    object.  This is an alias for <code>grid.dvi()</code> - the rendering
    happens within the current 'grid' viewport.
  </p>
    <rcode fig.width="1" fig.height=".5"><![CDATA[
render(dvi)
  ]]></rcode>
    <p>
    Rendering consists of two steps internally:
  </p>
    <ol>
      <li>
        <p>
        We walk the list of DVI operations and build a list of 
        objects, mostly either <code>"XDVIRglyphObjglyph"</code> objects, 
        which describe
        glyphs, the fonts they come from, and where to draw them, 
        or <code>"XDVIRruleObj"</code>, which correspond to rectangles to draw
        (the only core TeX drawing operation).        
      </p>
        <p>
        This step also gathers bounding box information which is vital
        for sizing and positioning the grobs that are produced in the
        second step.
      </p>
      </li>
      <li>
        <p>
        We walk the list of objects and build a gTree of grobs,
        mostly either <code>"glyphgrob"</code>s, <code>"rect"</code> grobs,
        or <code>"segments"</code> grobs.
      </p>
        <p>
        Consecutive glyph operations in the DVI file are collapsed into
        a single <code>"glyphgrob"</code>, but we may end up with
        multiple <code>"glyphgrob"</code>s if, for example, 
        a mathematical equation includes a horizontal line.
        In that case, in order to preserve the order of drawing,
        we end up with a <code>"glyphgrob"</code> for one or more
        glyphs before a <code>"rect"</code> then another 
        <code>"glyphgrob"</code> for one or more further glyphs.
      </p>
      </li>
    </ol>
    <p>
    Justification of the rendering is complicated because we 
    potentially need to
    justify a combination of multiple <code>"glyphgrob"</code>s, plus
    lines and/or rectangles.
    The solution is to generate common "anchors" for all
    <code>"glyphgrob"</code>s based on the bounding box for the 
    rendering and to calculate an "offset" for lines and rectangles
    based on how much a "dummy" glyph positioned at the bottom-left of
    the bounding box would have to move to satisfy the justification.
  </p>
    <h3>Packages, engines, and font libraries</h3>
    <p>
    It is possible to specify the <code>packages</code> and
    <code>engine</code> for rendering, though they will be taken
    from the <code>"DVI"</code> object if possible.
    Checks are made for inconsistency between the user specification
    and the signature in the <code>"DVI"</code> object, if there is one.
  </p>
    <p>
    It is also possible to specify a font library, which is used to
    get glyph metrics (for calculating glyph positions and the overall
    bounding box).  There is a default font library based on FreeType
    (CITE) and no other option is provided (on CRAN).
    Section <a href="#fontlibs">Font libraries</a> has more information.
  </p>
    <h3>Vectorisation</h3>
    <p>
    The <code>render()</code> function is vectorised.
    The <code>dvi</code> argument to <code>render()</code> can be
    a list of <code>"DVI"</code> objects, 
    which can each be drawn at different (<code>x</code>, <code>y</code>)
    locations, at different <code>rot</code>ations,  and
    with different <code>hjust</code> and <code>vjust</code>
    justitications.
    The <code>gp</code> settings are also vectorised and applied
    to the corresponding <code>"DVI"</code> object.
    On the other hand, the <code>packages</code>, <code>engine</code>,
    and <code>fontLib</code> are fixed for all <code>"DVI"</code> objects.
  </p>
    <p>
    A <code>margin</code> and <code>rot</code>ation can be specified
    for rendering and these are implemented via viewports on the
    overall gTree.
  </p>
    <h3>Resolution</h3>
    <p>
    dpi
  </p>
    <h3>Multiple pages</h3>
    <h2>
      <a name="packages">5. Packages</a>
    </h2>
    <h2>
      <a name="engines">6. Engines</a>
    </h2>
    <h2>
      <a name="fontlibs">7. Font libraries</a>
    </h2>
    <h2>TikZ</h2>
    <p>
    There are TikZ obejcts
  </p>
    <h2>TODO</h2>
    <p>
    Use the ChartAccent paper and its references to justify the
    need for tools that can add annotations.
  </p>
    <p>
      <strong>PROVIDE a map of the structure of the report</strong>
    </p>
    <p>
    Examples:
  </p>
    <ul>
      <li>
      dpi arg.
      Gaussian equation a decent example
      (though note that unicode-math means heavier rules!)
    </li>
      <rcode><![CDATA[
tex <- r"(\huge $\Phi(z) = \frac{1}{\sqrt{2\pi}} \cdot e^{-\frac{z^2}{2}}$)"
    ]]></rcode>
      <li>
      Tables, multi-column, etc
    </li>
      <li>
      Combination of text and math
    </li>
      <li>
      Various alignment options (esp, baseline, esp. with math)
    </li>
      <li>
      Packages: Colours, fonts
    </li>
      <li>
      Do example of creating graphicx package external to {xdvir}.
    </li>
      <li>
      TikZ (and mixture of TikZ with text etc).
      <code>tikzPackage()</code> vs <code>tikzPicture()</code>.
    </li>
      <li>
      Vertical text
    </li>
      <li>
      All of the above on different engines (mostly LuaTeX and XeTeX).
    </li>
    </ul>
    <p>
    Delayed rendering from grid.latex() - when, why, how
  </p>
    <p>
    Name check the 'dvir' package.
  </p>
    <p>
    New focus on glyphGrob()s instead of textGrob()s.
  </p>
    <p>
    baseline support (via 'preview' at least).
    Puts <code>dvir-preview</code> output with height, depth, and width in DVI file.
    Sets "preview-baseline" (vertical) anchor.
    Used for aligning grid.typeset() for now.
    Could be used for more sophisticated alignment of grid.*latex()
    as well in future (?).
  </p>
    <p>
    Support for colours (via 'xcolor' at least).
    <code>grid.lualatexTypeset()</code> and <code>grid.xelatexTypeset)</code> default
    to using both 'preview' and 'xcolor'.
    Need to add support for colour with <code>grid.latex()</code> etc.
  </p>
    <p>
    fontspec support (as package)
  </p>
    <p>
    upTeX support for vertical text direction (e.g., Japanese).
    The 'patchDVI' vignette "Using Sweave and patchDVI with Japanese
    text" has some advice for which LaTeX packages and settings to
    use for Japanese text.
  </p>
    <p>
    NOTE that these features are all pretty much orthogonal.
  </p>
    <p>
    Font library (and default and setting and how to define one, including
    the argument list for all methods).
  </p>
    <p>
    Package message on start up that reports on availability and
    versions of tools.
  </p>
    <p>
    Summary of install options:
  </p>
    <p>
    Could have a section on efficiency, especially for things like
    R markdown documents that get run over and over again.
    Use author(), typeset(),
    and readDVI() so do not keep having to rerun TeX engine.
    Generate latexGrob() so do not have to keep running that step
    (may also have to use forceGrob() IF make a makeContent() method
    so that calculations are redone on, e.g., device resize).
  </p>
    <p>
    BIG mention of Type 1 fonts ([mostly] not supported) vs True Type
    and Open Type.
  </p>
    <p>
    Because we use grid.glyph(), only works with R &gt;= 4.3.0 and 
    on Cairo, or pdf(), or quartz() (so far).
  </p>
    <p>
    Note on embedding fonts in pdf() - convenience function to
    extract glyphInfos from dviGrob to feed to embedGlyphs() ?
    NOTE that embedGlyphs() can now accept list of glyphInfo
    (which is necessary because dviGrob will often contain more
    than one glyphGrob).
  </p>
    <p>
    Because we use grid.glyph(), lualatexGrob()s (et al) are
    specific to computer that they are created on (for font file
    paths). OTOH, that is also true of the DVI files that contain
    font file paths!!  (XeTeX and modern LuaTeX).
  </p>
    <p>
    Packages:  convenient (yet flexible) specification of packages
    via aliases;  new packages can be defined by users and added
    to the package register;  package definition consists of 
    preamble, prefix, suffix, and special (simple example is xcolor,
    incredibly complex example is tikz, somewhere in between
    is preview).
  </p>
    <p>
    Package complications:  order matters, both for loading packages,
    but even more for nesting of prefixes/suffixes.
  </p>
    <p>
    Breakdown of 'xdvir' components.
    functions like <code>lualatexGrob()</code> hide multiple
    steps:  <code>author()</code> to generate TeX document from
    TeX fragment;  <code>typeset()</code> to generate DVI file from
    TeX document;  <code>readDVI()</code> to read DVI file into R;
    <code>dviGrob()</code> to generate grobs from DVI.
    All of those, except <code>readDVI()</code> take an
    <code>engine</code> argument.
    Both <code>author()</code> and <code>dviGrob()</code> also
    take a <code>packages</code> argument.
    Ideally <code>engine</code> and <code>packages</code>
    would be consistent across calls, but variations
    are possible and should not break even if they drop some features (?).
    The structure also allows entry points other than a TeX fragment.
    For example, you can write your own TeX document and you can even
    start from a DVI file generated elsewhere.  However, in those cases
    you REALLY need to know what you are doing and you need to carefully
    select at least an appropriate engine, if not also packages.
    Can even make a new engine BUT NOTE that engine "options" must
    be a character vector (one value per option).
  </p>
    <p>
      <img src="Diagram/system.png" alt="Diagram of 'xdvir' components" style="max-width: 100%"/>
    </p>
    <p>
    Detailed discussion of differences from 'dvir':
    reimplementation of lualatex support;
    no fontconfig;
    no subset fonts;
    no viewport;
    glyphs not text;
    font files not font family etc;
    not device-specific (although only devices with dev-&gt;glyph() support);
    all metrics via fonts rather than via dev-&gt;stringMetric();
    no need to map TeX font to stupid R font spec.
  </p>
    <p>
    Related work:  'latex2exp' (convert LaTeX to R expression, still drawn
    using plotmath);  'tikzDevice' (put R in TeX rather than the other way
    around - no longer maintained?);  'textshaping' (limited typesetting);
    'geomtextpath' (text along a path!);  'ggpage' (draws paragraphs of text
    BUT with very simplistic typesetting algorithm based on 
    stringr::str_wrap()?); 

    <a href="https://matplotlib.org/stable/tutorials/text/usetex.html">Text rendering with LaTeX</a> in matplotlib (in Python).
That mentions some limitations.
This one mentions cache to avoid processing same tex twice
https://matplotlib.org/stable/gallery/text_labels_and_annotations/tex_demo.html 

    'marquee' (!!) under development.

    dvi-decode javascript module for rendering DVI in browser
    https://latex.org/forum/viewtopic.php?t=35259
    (this has some very familiar constraints ...
    https://github.com/matjp/dvi-decode)

    Commercial product
    Using LaTeX to Add Mathematical Expressions to Plot Titles | COMSOL Blog
    https://www.comsol.com/blogs/using-latex-to-add-mathematical-expressions-to-plot-titles#:~:text=To%20add%20LaTeX%20commands%20in,for%20the%20display%20math%20mode

  </p>
    <p>
    Future work:
    
    Integrate 'xdvir' with 'tikzDevice' 
    =&gt; latex in grid in latex ...

    add interface to allow latex in ggplot2 titles etc
    as per ggtext and marquee.
  </p>
    <p>
    Limitations:

    need device with glyph support;
    XeTeX and LuaTeX only;
    LuaTeX only if luaotfload-tool verion is &gt; 3.15;
    May need recent LuaTeX (e.g., 1.17.0 as available on Ubuntu 24.04)
    to get reliable full font file paths (and glyph ids) in DVI output;
    must specify fonts by file path when using fontspec

    Specifying 'width' is approximate - use minipage to get more 
    precise and reliable control.
  </p>
    <h2>
      <a name="requirements">8. Technical requirements</a>
    </h2>
    <p>
    The examples and discussion in this report relate to 
    R version 4.3.0 and 'dvir' version 0.4-0.
    Any example using <code>embedGlyphs()</code> (to embed fonts in PDF
    output) with <em>list</em> of glyph info
    will need R-devel!
  </p>
    <p>
    This report was generated within a Docker container
    (see <a href="#Resources">Resources</a> section below).
  </p>
    <h2>
      <a name="Resources">9. Resources</a>
    </h2>
    <ul>
      <li>
      The <a href="xetex.cml">raw source file</a> for this
      report, a <a href="xetex.xml">valid XML</a>
      transformation of the source file, a <a href="xetex.Rhtml">'knitr' document</a> generated from
      the XML file, 
      two <a href="toc.R">R</a> <a href="bib.R">files</a> and
      the <a href="xetex.bib">bibtex file</a>
      that are used to generate the table of contents and reference sections,
      two <a href="common.xsl">XSL</a> <a href="knitr.xsl">files</a> and an 
      <a href="knit.R">R file</a> that are used to transform the XML to
      the 'knitr' document, and a <a href="Makefile">Makefile</a> that
      contains code for the other transformations and coordinates
      everything.  
      These materials are also available
      on <a href="https://github.com/pmur002/xetex-report/releases/tag/v1">github</a>.
    </li>
      <li>
      This report was generated within a 
      <a href="https://www.docker.com/">Docker</a> container.
      The Docker command to build the report is included in the Makefile above.
      The Docker image for the container is available from
      <a href="https://hub.docker.com/r/pmur002/xetex-report/">Docker Hub</a>;
      alternatively, the image can be rebuilt from its 
      <a href="Dockerfile">Dockerfile</a>.
    </li>
    </ul>
    <h2>How to cite this report</h2>
    <p>
    Murrell, P. (2022). "" 
    Technical Report 2022-??, Department of Statistics, The University of Auckland. 
    Version 1.
    [ <a href="how-to-cite.bib">bib</a> |
      <a href="http://dx.doi.org/">DOI</a> | 
      <a href="https://stattech.blogs.auckland.ac.nz/">http</a> ]
  </p>
    <h2>
      <a name="references">10. References</a>
    </h2>
    <ul style="list-style-type: none">
      <li>
        <a name="R"/>
      </li>
      <li>
        <a name="xdvir-pkg"/>
      </li>
      <li>
        <a name="murrell-pedersen-urbanek-glyphs-2023"/>
      </li>
    </ul>
    <h2>Footnotes</h2>
    <div>
      <p class="footnote"> 
g     <a name="beausoleil"/>
      This plot example was inspired by a 
      <a href="https://stackoverflow.com/questions/75889406/typing-long-text-in-legend-with-automatic-line-return-and-mathematical-notation">post on 
      Stack Overflow</a> by Marc-Olivier Beausoleil.
      The final image is a simplified version of one frame from an 
      animation that was designed to explain the derivation of 
      an "adaptive landscape" from a "fitness function".
      Many thanks to Marc-Olivier for sharing his code.
    </p>
    </div>
    <hr/>
    <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="CC" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
  </body>
</html>
