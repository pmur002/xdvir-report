<?xml version="1.0" encoding="UTF-8"?>
<html>
  <head>
    <title>LaTeX Typesetting in R</title>
    <style type="text/css">
    @media print {
      body { }
      p.img { text-align: center; page-break-inside: avoid }
      img.CC { display: inline }
    }
    @media screen {
      body { max-width: 800px; margin: auto }
      p.img { text-align: center }
      img.CC { display: inline }
    }
    p.date {
      font-size: smaller;
      margin: 0;
    }
    p.versionHistory {
      color: gray
    }
    p.versionHistory a {
      color: gray
    }
    p.ref {
      text-indent: -2em;
      padding-left: 2em;
    }
    p.fig {
      text-align: left;
    }
    p.fig img, img.plot {
      box-shadow: 10px 10px 20px;
      margin-top: 10px;
      margin-bottom: 20px;      
    }
  </style>
    <script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
  </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>
  </head>
  <body>
    <h1>LaTeX Typesetting in R: The 'xdvir' Package</h1>
    <p>
      <span style="font-style: italic">by Paul Murrell</span>
      <a href="http://orcid.org">
        <img alt="" src="https://www.stat.auckland.ac.nz/~paul/ORCID/ORCiD.png" style="width: 16px; height: 16px; vertical-align: middle"/>
      </a>
      <span style="font-family: mono; font-size: small">
        <a href="http://orcid.org/0000-0002-3224-8858">http://orcid.org/0000-0002-3224-8858</a>
      </span>
    </p>
    <p class="date">
    Version 1:  
    <rcode echo="FALSE" results="asis"><![CDATA[
cat(format(Sys.Date(), "%A %d %B %Y"))
    ]]></rcode>
  </p>
    <rcode id="init" echo="FALSE" message="FALSE" results="hide"><![CDATA[
opts_chunk$set(comment=" ", tidy=FALSE, 
               dev="png", ## dev="svg",
               dpi=96)
options(width=100)
## For wonky desktop set up
options(bitmapType="cairo")
  ]]></rcode>
    <rcode echo="FALSE" message="FALSE"><![CDATA[
    library(grid)
  ]]></rcode>
    <hr/>
    <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="CC" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
    <hr/>
    <p>
    This document describes some lower-level, technical details
    of the CRAN package 'xdvir' for rendering LaTeX fragments
    as labels and annotations on R plots.
  </p>
    <div>
      <h2>Table of Contents:</h2>
      <ul style="list-style: none">
        <li>
          <a href="#intro">1. Introduction</a>
        </li>
        <li>
          <a href="#author">2. Authoring</a>
        </li>
        <li>
          <a href="#typeset">3. Typesetting</a>
        </li>
        <li>
          <a href="#render">4. Rendering</a>
        </li>
        <li>
          <a href="#packages">5. Packages</a>
        </li>
        <li>
          <a href="#tikz">6. TikZ</a>
        </li>
        <li>
          <a href="#engines">7. Engines</a>
        </li>
        <li>
          <a href="#fontlibs">8. Font libraries</a>
        </li>
        <li>
          <a href="#discussion">9. Discussion</a>
        </li>
        <li>
          <a href="#requirements">10. Technical requirements</a>
        </li>
        <li>
          <a href="#Resources">11. Resources</a>
        </li>
        <li>
          <a href="#references">12. References</a>
        </li>
      </ul>
    </div>
    <h2>
      <a name="intro">1. Introduction</a>
    </h2>
    <p>
    The 'xdvir' package for R 
    (<a href="#xdvir-pkg"/>) 
    allows LaTeX fragments to be used as
    labels and annotations on R plots,
    including 'ggplot2' plots.  The 
    <a href="https://cran.r-project.org/web/packages/xdvir/vignettes/xdvir-intro.html">package vignette</a> 
    describes basic high-level usage 
    and an <a href="https://github.com/pmur002/xdvir-rjournal">article 
    submitted to the R Journal</a>
    explains more about the standard usage of the package 
    and has more complex examples.
    The purpose of this document is to provide a description
    of some more advanced features of the package, including ways to
    extend the package, and to provide a record of the 
    lower-level design and implementation of the package.
  </p>
    <p>
    The package startup detects and reports on which TeX engines are available
    on the current system.  This report is built on a system
    with XeTeX and an acceptable version of LuaTeX, so both of those
    engines are available.  This means that the default engine
    for building this report is LuaTeX.
  </p>
    <rcode><![CDATA[
library(xdvir)
  ]]></rcode>
    <rcode><![CDATA[
    getOption("xdvir.engine")$name
  ]]></rcode>
    <p>
    Rendering a LaTeX fragment in R involves three steps:
  </p>
    <ol>
      <li><strong>Authoring:</strong> The LaTeX fragment has to be augmented
      to create a complete LaTeX document.
    </li>
      <li><strong>Typesetting:</strong> The LaTeX document has to be typeset to
      create a file of DVI operations and that DVI file has to be
      read into an R data structure.
    </li>
      <li><strong>Rendering:</strong> The DVI data structure has to be turned
      into R graphics drawing operations.
    </li>
    </ol>
    <p>
    This document begins by taking a closer look at each of those three steps.
  </p>
    <p>
      <img src="diagram/diag.png" alt="The high-level design of the xdvir package." style="max-width: 100%"/>
    </p>
    <h2>
      <a name="author">2. Authoring</a>
    </h2>
    <p>
    The <code>author()</code> function turns a LaTeX fragment into 
    a LaTeX document.  This consists of adding additional
    LaTeX code around the LaTeX fragment.
  </p>
    <rcode><![CDATA[
fragment <- "test"
author(fragment)
  ]]></rcode>
    <p>
    There are some obvious additions, like <code>\begin{document}</code> and
    <code>\end{document}</code>.  
  </p>
    <p>
    The <code>\documentclass</code> is always
    <code>standalone</code>.  This is partly because that seems sensible - the
    LaTeX fragments are not complete documents, but typically small labels to be
    added to other drawing - but also because that will not produce, for
    example, any page numbering or headers and footers that you normally
    get from something like the standard <code>article</code> class.
  </p>
    <p>
    The <code>varwidth</code> option is set for the <code>standalone</code>
    class.  This is not always necessary and it may actually cause
    problems if the width of the label exceeds the text width of 
    a standard article.  However, the <code>width</code> argument
    to <code>author()</code> can be used to specify an explicit width
    if that is convenient and/or if that is necessary.
    This uses the <code>varwidth</code> option to set an explicit width.
    If given, the <code>width</code> is interpreted as a number of inches.
  </p>
    <rcode><![CDATA[
author(fragment, width=2)    
  ]]></rcode>
    <p>
    The <code>\usepackage{unicode-math}</code> is there to force the TeX engine
    to use TrueType math fonts and to produce font file paths in DVI output.
    Without this, you tend to get <code>fnt_def</code> operations in the DVI
    output of the form <code>cmmi10</code>.  Those not only require 
    a potentially complicated further mapping to get to
    actual font files, but they resolve to Type 1 fonts.  That is a problem
    because the rendering of LaTeX fragments in R 
    requires a graphics device that has
    support for rendering glyphs
    <a href="murrell-pedersen-urbanek-glyphs-2023"/>
    and the main set of those is the Cairo devices and they 
    no longer support Type 1 fonts.
  </p>
    <p>
    The comment on the first line records information about the version of
    'xdvir', the TeX engine that was used to author the document, and the LaTeX
    packages that were specified.  As noted previously, the engine defaults on
    package startup.  This information is used in the typesetting step to check
    that compatible TeX engines and packages were used in the authoring step.
  </p>
    <p>
    We can use the <code>engine</code> and
    <code>packages</code> arguments to <code>author()</code> to explicitly set
    those values.  Notice that the addition of <code>packages="xcolor"</code>
    adds a new
    <code>\usepackage</code> line and it adds to
    the comment on the first line.  
    The <code>engine</code> just turns up in the first line of comments.
  </p>
    <rcode><![CDATA[
author(fragment, engine="xetex", packages="xcolor")    
  ]]></rcode>
    <p>
    Some packages will add more lines.  For example, the <code>preview</code>
    package adds further LaTeX code 
    to the document preamble and wraps the fragment
    within a <code>preview</code> environment.  
  </p>
    <rcode><![CDATA[
author(fragment, packages="preview")    
  ]]></rcode>
    <p>
    Functions like <code>grid.latex()</code> and <code>geom_latex()</code>
    also add additional code to LaTeX fragments in order to 
    match the current font family, font face, and font size.
    We can easily see this if we use the <code>texFile</code> argument
    to control the name of the file that 'xdvir' writes a full LaTeX
    document into.
    For example, the following code draws a simple LaTeX fragment
    and automatically matches the R default font family (rather than
    using the default LaTeX Computer Modern font)
    and writes the full LaTeX document to the file <code>"test.tex"</code>.
    The font matching is implemented by adding <code>\setmainfont</code> and
    <code>\fontsize</code> commands to the LaTeX document 
    (plus <code>\usepackage{fontspec}</code>).
  </p>
    <rcode fig.width="1" fig.height=".5"><![CDATA[
grid.latex(fragment, texFile="test.tex")
cat(readLines("test.tex"), sep="\n")
  ]]></rcode>
    <p>
    Where user-level functions add a lot
    of additional code to the LaTeX fragment, like the examples above, 
    there is a risk of 
    conflicting with the LaTeX fragment and/or a risk of 
    packages conflicting with each other.  This is one possible
    reason for authoring a LaTeX document directly rather than relying
    on the <code>author()</code> function.
    However, care must be taken in that case to retain features like
    <code>\usepackage{unicode-math}</code> so that 
    DVI output that is consumable by 'xdvir' 
    is produced during the typesetting step.
  </p>
    <p>
    In other words, here be dragons.  On the positive side, I have yet
    to irretrievably bite myself with this problem.
  </p>
    <h2>
      <a name="typeset">3. Typesetting</a>
    </h2>
    <p>
    The <code>typeset()</code> function processes a LaTeX document
    to a <code>"DVI"</code> object.
    The LaTeX document can be a <code>"LaTeXdocument"</code>
    object, as produced by <code>author()</code>
    or just a character vector (though the latter must be a complete
    LaTeX document, not just a LaTeX fragment).
  </p>
    <rcode><![CDATA[
doc <- author(fragment)
dvi <- typeset(doc)
dvi
  ]]></rcode>
    <p>
    The <code>typeset()</code> function generates a DVI file by 
    writing the LaTeX document to a file and running a TeX engine
    to produce a DVI file.
    'xdvir' makes use of <code>latexmk()</code> from the 'tinytex'
    package for this step, which automatically takes care of 
    multiple runs of the TeX engine and even installing missing 
    LaTeX packages in at least some cases.
  </p>
    <p>
    The DVI file is read into R as a <code>"DVI"</code> object and
    the <code>"DVI"</code> object has a print method to show the contents
    of a DVI file in a human-readable format.
    Underneath, it is a list of <code>"rawFormat"</code>
    objects from the 'hexView' package, which are  labelled blocks of 
    raw bytes along with interpreted values (integers, strings, etc).
    For example, the first element of the <code>dvi</code> object
    is a DVI <code>pre</code>
    operation, which consists of a one-byte integer operation code
    (247), followed by a one-byte integer DVI version number (2),
    and so on.
  </p>
    <rcode><![CDATA[
dvi[[1]]
  ]]></rcode>
    <p>
    Notice that <code>typeset()</code> embeds a "signature" in
    the <code>pre</code> operation of the DVI file that records 
    information about the 'xdvir' version, the TeX engine used,
    and any LaTeX packages used.  This information is used in the
    rendering step 
    to check that compatible TeX engines and packages are used in each
    step.
    Warnings are given if information is missing or inconsistent.
  </p>
    <p>
    There is an <code>engine</code> argument to allow the TeX engine
    to be specified, but it will default from information in the
    LaTeX document if that exists.
  </p>
    <h3>Debugging</h3>
    <p>    
    The typesetting step is probably where most user problems will occur, 
    most probably because the LaTeX fragment (or the LaTeX
    document) contains an error, so the call to a TeX engine fails.
    For example, the following code adds a <code>$</code> to the 
    previous LaTeX fragment to produce an illegal LaTeX fragment.
  </p>
    <rcode><![CDATA[
bugFrag <- paste(fragment, "$")
bugFrag
  ]]></rcode>
    <p>
    When we build a complete LaTeX document and attempt to typeset it,
    we get an error from the TeX engine.
  </p>
    <rcode><![CDATA[
docBug <- author(bugFrag)
typeset(docBug)    
  ]]></rcode>
    <p>
    The <code>texFile</code> argument is useful in cases like this because
    the <code>.log</code> file will be in the same location as the
    <code>texFile</code>, so we can easily see what the problem is.
    Using <code>texFile</code> is also a good way to
    easily get hold of the LaTeX document and run a TeX engine on it
    outside of R to debug the problem.
  </p>
    <h3>Caching</h3>
    <p>
    'xdvir' automatically caches typsetting results. If the combination of
    LaTeX document, TeX engine, and LaTeX packages has been seen before
    then a cached <code>"DVI"</code> object will be used.
    Ths means that the expensive typesetting step
    should only occur once per unique TeX fragment (per session).
  </p>
    <p>
    For debugging problems, it can be useful to turn off caching 
    with <code>options(xdvir.useDVIcache=FALSE)</code>.
  </p>
    <h3>Manual typesetting</h3>
    <p>
    Because <code>typeset()</code> accepts a simple character vector,
    it is easy to author a LaTeX document outside of R and
    just <code>readLines()</code> that document to pass it to 
    <code>typeset</code>.
  </p>
    <rcode><![CDATA[
doc <- readLines("test.tex")
dvi <- typeset(doc)
  ]]></rcode>
    <p>
    It is also possible to perform the typesetting outside of R and
    just read a DVI file in using <code>readDVI()</code>.
    The important thing here is to make sure that you produce a DVI file, e.g.,
    <code>xelatex --no-pdf</code> or
    <code>lualatex --output-format=dvi</code>.
  </p>
    <h2>
      <a name="render">4. Rendering</a>
    </h2>
    <p>
    The <code>render()</code> function renders a <code>"DVI"</code>
    object.  This is an alias for <code>grid.dvi()</code> - the rendering
    happens within the current 'grid' viewport.
  </p>
    <rcode fig.width="1" fig.height=".5" warning="FALSE"><![CDATA[
render(dvi)
  ]]></rcode>
    <p>
    Rendering consists of two steps internally:
  </p>
    <ol>
      <li>
        <p>
        We walk the list of DVI operations and build a list of 
        objects, mostly either <code>"XDVIRglyphObjglyph"</code> objects, 
        which describe
        glyphs, the fonts they come from, and where to draw them, 
        or <code>"XDVIRruleObj"</code> objects, 
        which correspond to rectangles to draw
        (the only core TeX drawing operation).        
      </p>
        <p>
        This step also resolves font definitions and
        gathers bounding box information, which is vital
        for sizing and positioning the grobs that are produced in the
        second step.
      </p>
      </li>
      <li>
        <p>
        We walk the list of objects and build a gTree of grobs,
        mostly either <code>"glyphgrob"</code>s, <code>"rect"</code> grobs,
        or <code>"segments"</code> grobs.  Segments are used for
        very thin rectangles because very thin filled rectangles 
        tend to disappear on raster devices, including on screen.
      </p>
        <p>
        Consecutive glyph operations in the DVI file are collapsed into
        a single <code>"glyphgrob"</code>, but we may end up with
        multiple <code>"glyphgrob"</code>s if, for example, 
        a mathematical equation includes a horizontal line.
        In that case, in order to preserve the order of drawing,
        we end up with a <code>"glyphgrob"</code> for one or more
        glyphs, before a <code>"rect"</code> for the line, then another 
        <code>"glyphgrob"</code> for one or more further glyphs.
      </p>
      </li>
    </ol>
    <p>
    Justification of the rendering is complicated because we 
    potentially need to
    justify a combination of multiple <code>"glyphgrob"</code>s, plus
    lines and/or rectangles.
    The solution is to generate common "anchors" for all
    <code>"glyphgrob"</code>s based on the bounding box for the 
    rendering and to calculate an "offset" for lines and rectangles
    based on how much a "dummy" glyph positioned at the bottom-left of
    the bounding box would have to move to satisfy the justification.
  </p>
    <p>
    A <code>margin</code> and <code>rot</code>ation can be specified
    for rendering and these are implemented via viewports on the
    overall gTree.
  </p>
    <h3>Packages, engines, and font libraries</h3>
    <p>
    It is possible to specify the <code>packages</code> and
    <code>engine</code> for rendering, though they will be taken
    from the <code>"DVI"</code> object if possible.
    Checks are made for inconsistency between the user specification
    and the signature in the <code>"DVI"</code> object, if there is one.
    Warnings are given if information is missing or inconsistent.
  </p>
    <p>
    It is also possible to specify a font library, which is used to
    get glyph metrics (for calculating glyph positions and the overall
    bounding box).  There is a default font library based on FreeType
    (<a href="#freetype2"/>) and no other option is provided (on CRAN).
    Section <a href="#fontlibs">Font libraries</a> has more information.
  </p>
    <h3>Vectorisation</h3>
    <p>
    The <code>render()</code> function is vectorised.
    The <code>dvi</code> argument to <code>render()</code> can be
    a list of <code>"DVI"</code> objects, 
    which can each be drawn at different (<code>x</code>, <code>y</code>)
    locations, at different <code>rot</code>ations,  and
    with different <code>hjust</code> and <code>vjust</code>
    justifications.
    The <code>gp</code> settings are also vectorised and applied
    to the corresponding <code>"DVI"</code> object.
    On the other hand, the <code>packages</code>, <code>engine</code>,
    and <code>fontLib</code> are fixed for all <code>"DVI"</code> objects
    in a single <code>render()</code> call.
  </p>
    <h3>Resolution</h3>
    <p>
    By default, DVI positions and font metrics are used at maximum
    resolution (typically 72*2^16 scaled points per inch and
    72*10*1000 units per inch, where 10 is the font point size, respectively) 
    and R uses its default naive infinite resolution
    calculations to position glyphs and to determine dimensions,
    such as the bounding box.
  </p>
    <p>
    However, it is also possible to specify a <code>dpi</code> 
    resolution, in which case glyph locations and font dimensions
    are rounded to the nearest "pixel".  This uses an algorithm
    that produces identical results to <code>dvitype</code> 
    (<a href="#knuth1982dvitype"/>)
    at multiple resolutions on an identical DVI file
    (see <code>tests/dpi.R</code>).
  </p>
    <p>
    Using <code>dpi</code> may make sense if you know the dpi of 
    the target graphics device, though I have yet to see convincing
    evidence of improvement.  This may be because the <code>dpi</code>
    rounding does
    not guarantee alignment with pixels on the device because there 
    are subsequent calculations on the rounded dpi locations
    to satisfy justification.
  </p>
    <h3>Multiple pages</h3>
    <p>
    It is possible for a DVI file to contain multiple pages.
    While this is unlikely to be the typical case for LaTeX 
    fragments, it could still occur if a LaTeX document is generated
    outside of R.
  </p>
    <p>
    In such a case, <code>readDVI()</code> will read all pages into
    a <code>"DVI"</code> object, but only the operations 
    on the <code>page</code> specified to <code>render()</code>
    will generate objects and operations on other pages will be ignored.
  </p>
    <p>
    To be more accurate, some operations, such as positioning and setting
    of fonts will be listened to on all pages in case settings
    carry over across pages, but those operations will not
    generate any objects themselves.
  </p>
    <h3>Delayed rendering</h3>
    <p>
    The creation of <code>"glyphgrob"</code>s is delayed, in the sense
    of happening within a <code>makeContent()</code> method,
    because the calculation of anchors and offsets for justification
    has to occur at drawing time, once the rendering viewport is known.
    This means that grob queries, such as <code>grobWidth()</code>
    incur a penalty because they have to generate final grobs
    (though not necessarily <code>"glyphgrob"</code>s).
  </p>
    <p>
    There can be a further layer of delay when calling 
    <code>grid.latex()</code> because the author step has to occur
    at drawing time if the <code>width</code> requires converting to
    inches and/or the current font has to be queried (so we need to
    know the final rendering viewport).
    This delay does not occur if <code>width</code> is not specified
    and/or it is in absolute units <em>and</em> <code>gp</code>
    is set to <code>NULL</code> (so the "current" font settings
    are ignored).  This additional delay results in additional
    penalties for grob queries.
  </p>
    <h2>
      <a name="packages">5. Packages</a>
    </h2>
    <p>
    'xdvir' provides predefined support for several LaTeX packages:
    fontspec, xcolor, preview, zref, and tikz (see the
    <a href="#tikz">TikZ</a> Section).
  </p>
    <p>
    There are obviously many more LaTeX packages that 
    users might want to make use of in their LaTeX fragments.
    One approach is to write an entire LaTeX document by hand, which
    means you can include whatever packages you need.
    However, this is not the most convenient and will not work,
    for example, with the 'ggplot2' interfaces <code>geom_latex()</code>
    and <code>element_latex()</code>.
  </p>
    <p>
    So there is a mechanism for defining support for additional LaTeX packages
    in the form of the <code>LaTeXpackage()</code> function
    (plus the <code>registerPackage()</code> function).
  </p>
    <p>
    The <code>name</code> argument provides convenience.
    If the package is registered, then it can be referred to by this
    name (which is what previous examples have done with predefined packages).
  </p>
    <p>
    The <code>preamble</code> argument is LaTeX code that will be placed in
    the LaTeX document preamble in the authoring step.
    This is often just a <code>\usepackage</code> command, but 
    the preview package example earlier showed that other LaTeX
    code can be included.
  </p>
    <p>
    The <code>prefix</code> and <code>suffix</code> arguments are LaTeX code 
    that is wrapped around the LaTeX fragment in the authoring step.
    A typical use would be to wrap the LaTeX fragment in a LaTeX
    environment (like the preview package does).
  </p>
    <p>
    The <code>special</code> argument is a function.
    This is useful for packages that generate DVI specials, like xcolor.
    The following code authors and typesets a simple LaTeX fragment
    that draws text in red.
    The resulting DVI output contains DVI specials, which are marked
    as <code>xxx1</code> operations.
    These have been  produced by the xcolor package
    and contain information about changes in colour.
    For example <code>color push gray 0</code> sets the text colour
    to black and <code>color push rgb 1 0 0</code> sets it to red.
  </p>
    <rcode><![CDATA[
tex <- author("\\color{red} test", packages="xcolor")
dvi <- typeset(tex)
dvi
  ]]></rcode>
    <p>
    The rendering step calls the <code>special</code> function
    (if not <code>NULL</code>) for every registered package,
    providing the content of the special (e.g., <code>color push gray 0</code>)
    as a character value, plus a <code>state</code> object.
    The latter is just an environment that can be used to maintain 
    state variables during the walk of DVI operations.
    For example, the <code>special</code> function for the xcolor
    package (in 'xdvir') maintains a stack of colours
    based on specials that start with <code>color</code> (and ignores
    all other specials).
  </p>
    <p>
    The <code>init</code> and <code>final</code> arguments are also functions
    that are called at the start and end of walking the DVI operations.
    These are passed a <code>state</code> object and allow initialisation 
    of state variables and anything else the package wants to do.
  </p>
    <p>
    In summary, the <code>LaTeXpackage()</code> function allows the user
    to specify LaTeX code that will be added to a LaTeX fragment during the
    authoring step and a function to handle specials during the rendering
    step that the LaTeX package
    generated in DVI output during the typesetting step.
  </p>
    <p>
    The <code>registerPackage()</code> function is used to 
    register the package with 'xdvir' so that it can be referred to by name.
  </p>
    <h2>
      <a name="tikz">6. TikZ</a>
    </h2>
    <p>
    The support for the tikz package in 'xdvir' is several
    orders of magnitude more complex than the support for other
    packages, so deserves its own mention.
  </p>
    <p>
    The LaTeX package TikZ (<a href="#tantau2013tikz"/>) 
    provides a sophisticated graphics system
    within the LaTeX world.  It generates graphical output by
    producing specials in the DVI output.
    For example, consider the TikZ fragment below
    (it is constructed in a slightly odd way to avoid 'knitr' errors).
    This describes a simple TikZ diagram that draws an arrow from "a" to "b".
  </p>
    <rcode><![CDATA[
tikzFrag <- paste0(r"(\draw[->] (0, 0) node[left] {a} -)",
                   r"(- (1, 0) node[right] {b};)")
tikzFrag
  ]]></rcode>
    <p>
    The following code augments that to a full LaTeX document,
    including additional LaTeX code to load the TikZ package
    and wrap the fragment within a <code>tikzpicture</code>
    environment.
    The <code>\def\pgfsysdriver</code> command is very important
    because this provides a backend for the TikZ package 
    that outputs TikZ specials designed for consumption by 'xdvir'.
    Without that command, TikZ would output specials consisting of
    PDF commands.
    This is another example of a detail that would have to be
    replicated if we author a complete LaTeX document (that included
    a TikZ picture) manually for use with 'xdvir'.
  </p>
    <rcode><![CDATA[
tikzDoc <- author(tikzFrag, packages="tikzPicture")
tikzDoc
  ]]></rcode>
    <p>
    Typesetting this document generates a large number of special
    operations in the DVI output, all starting with <code>xdvir-tikz::</code>
    so that the <code>special</code> function for the tikz package in 'xdvir' 
    will identify them and handle them.
  </p>
    <rcode><![CDATA[
tikzDVI <- typeset(tikzDoc)
tikzDVI
  ]]></rcode>
    <p>
    The <code>special</code> function for the tikz package in 'xdvir'
    calls a large number of other functions to maintain a lot of 
    state to keep track of where drawing needs to occur.
    It also generates a number of special <code>"XDVIRtikz*"</code>
    objects (that are not glyph or rule objects that normal 
    DVI operations produce) and 
    there are functions to convert those special tikz objects into
    'grid' grobs (in the second stage of the rendering step).
  </p>
    <p>
    At the high level, all of this internal activity is hidden and we can just
    call <code>grid.latex()</code> with the TikZ fragment and make sure to
    load the tikz package support, as shown below.
  </p>
    <rcode fig.width="2" fig.height=".5"><![CDATA[
grid.latex(tikzFrag, packages="tikzPicture")
  ]]></rcode>
    <h2>
      <a name="engines">7. Engines</a>
    </h2>
    <p>
    The 'xdvir' package has predefined support for 
    the XeTeX engine and the LuaTeX engine, though it insists on
    a recent version of the latter so that DVI output contains
    font file paths in font definitions and glyph indices in 
    <code>set_char</code> operations.
  </p>
    <p>
    This means that 'xdvir' cannot work with DVI output that is 
    generated by, for example, pdfTeX or upTeX, because those engines generate
    DVI output with font definitions that require resolving more complex 
    font file mappings and <code>set_char</code> operations that
    use a variety of different encodings.
  </p>
    <p>
    The door is left ajar for future development of support for other
    engines by providing the <code>TeXengine()</code> function
    (and the <code>registerEngine()</code> function).
  </p>
    <p>
    The <code>name</code> argument provides an easy way to refer to the
    engine if it is registered with 'xdvir'.
  </p>
    <p>
    The <code>version</code> argument is a function (with no arguments)
    that should return the version of the engine.
    This is used to construct comments in the authoring step and
    signatures in the typesetting step to check for consistency
    between steps.
  </p>
    <p>
    The <code>command</code> is a character value that gives the
    engine command (e.g., <code>"xelatex"</code>) and <code>options</code>
    are any additional options required to produce DVI output
    (e.g., <code>"--no-pdf"</code>).
    <code>dviSuffix</code> gives the suffix used for DVI output files
    (e.g., <code>.xdv</code>).
  </p>
    <p><code>isEngine</code> is a function that is called with a
    DVI object and should return whether the engine produced that 
    DVI object (used to help check for consistency).
  </p>
    <p>
    The <code>preamble</code> is LaTeX code that should be added
    in the authoring step.
  </p>
    <p>
    The <code>fontFile</code> and <code>glyphIndex</code> arguments
    are functions called during the rendering step to
    convert DVI operations into objects.
    <code>fontFile</code> is called with the content of a DVI font definition 
    (as a character value) and should return a font file path.
    <code>glyphIndex</code> is called with the content of a 
    <code>set_char</code> operation (as a set of raw bytes) and should
    return an integer glyph index.
  </p>
    <p>
    The implementation of <code>fontFile</code> and <code>glyphIndex</code>
    for XeTeX and (acceptable) LuaTeX is relatively straightforward,
    but these functions offer a possible path for other engine support, even if
    that support may require much more complex implementations.
  </p>
    <h2>
      <a name="fontlibs">8. Font libraries</a>
    </h2>
    <p>
    The 'xdvir' package relies on FreeType to access glyph
    metrics (for glyph placement and for bounding box calculations).
    The FreeType support is defined via an internal 
    <code>FontLibrary()</code> function that requires three functions
    to return glyph metric information.
    That function is not currently exported, but 'xdvir' internally 
    defines a different font library based on TTX 
    (<a href="#fonttools2025ttx"/>), which
    can be useful for debugging.
  </p>
    <h2>
      <a name="discussion">9. Discussion</a>
    </h2>
    <p>
    The 'xdvir' package provides a convenient high-level interface
    for using LaTeX fragments as plot labels and annotations in R.
    This document describes some of the details and internal design
    of the package, which may be helpful for diagnosing problems
    when things go wrong and possibly for extending the package.
  </p>
    <h3>Limitations</h3>
    <p>
    Rendering is slow.  The typesetting step requires at least 
    one run of a TeX engine.  Caching helps the second time around,
    but a plot that contains multiple unique TeX fragments can be glacial.
  </p>
    <p>
    As mentioned previously, 'xdvir' only supports
    XeTeX and 
    LuaTeX only if luaotfload-tool verion is &gt; 3.15.
  </p>
    <p>
    'xdvir' depends on R &gt;= 4.3 because it makes use of the
    glyph-rendering feature that was added in that version.
    This extends to requiring a graphics device that provides
    glyph-rendering, which currently includes
    <code>pdf()</code>,
    <code>quartz()</code>,
    the Cairo-based devices such as
    <code>cairo_pdf()</code> and
    <code>png(type="cairo")</code>,
    plus devices from the 'ragg' package (<a href="#pkg:ragg"/>).
  </p>
    <p>
    The PDF produced by
    <code>pdf()</code> 
    does NOT embed the fonts, so viewers may show 
    garbage glyphs.
    The <code>embedGlyphs()</code> function can be used
    to embed glyphs, but a little effort is required to extract the
    glyph information that <code>embedGlyphs()</code> requires
    from the 'grid' gTree that rendering produces.
  </p>
    <h3>Prior work</h3>
    <p>
    The 'xdvir' package is an evolution of the 'dvir' package 
    (<a href="#murrell-dvir"/>, <a href="#murrell-dvir-luatex"/>),
    which only exists on github.  'xdvir' has borrowed a lot 
    of code from 'dvir' (especially for TikZ support; 
    <a href="#murrell-dvir-tikz"/>), but streamlined
    some of the user interface, added integration with 'ggplot2',
    and massively simplified the handling of font definitions and
    glyph specifications in DVI output (by insisting that they
    contain font file paths and glyph indices, respectively).
    The 'xdvir' package also benefits from the glyph rendering support
    in R (from version 4.3), whereas 'dvir' had to struggle with
    the simplistic R text drawing of character values.
  </p>
    <h3>Related work</h3>
    <p>
    A number of R packages and other software perform a similar job
    to 'xdvir', but differ in various ways.  The following list
    focuses on the negatives of these other approaches, but they almost
    all have the <em>advantage</em>
    of NOT having massive dependencies (like 'xdvir'
    does with its need for a TeX installation) and NOT being slow
    (like 'xdvir' is with its typesetting step).
  </p>
    <ul>
      <li>
        <p>
        'latex2exp' converts LaTeX (mathematical equation) fragments to 
        R expressions, to be drawn using plotmath. 
        This helps LaTeX users to write plotmath expressions, but the
        end result is plotmath, which produces an inferior result to real
        LaTeX.  It also only supports LaTeX mathematical equations.
      </p>
      </li>
      <li>
        <p>
        'tikzDevice' converts R graphics into LaTeX graphics.
        This is basically the inverse of 'xdvir'.  If you want to end
        up in a LaTeX document, this might be the way to go.
        If you want to end up somewhere else, then 'xdvir' might be for you.
      </p>
      </li>
      <li>
        <p>
        'marquee' typesets and renders markdown.  The main difference
        is markdown rather than LaTeX.  Markdown can be easier to type,
        but LaTeX gives more control.
      </p>
      </li>
      <li>
        <p>
        There are some R packages that perform specific tasks,
        like 'geomtextpath' (text along a path) and  'ggpage' 
        (paragraphs of text), but they tend to be much more limited
        in their scope.
      </p>
      </li>
      <li>
        <p>
        In the Python world, there is a flag in matplotlib that switches
        all plot labelling to use LaTeX. 
        This uses a similar approach to 'xdvir' by generating and reading
        DVI output. 
        The main difference is where you want to produce
        your plots: Python/matplotlib versus R/ggplot2.
      </p>
      </li>
      <li>
        <p>
        The dvi-decode javascript module renders DVI files in a
        web browser.  It is quite general in theory, but
        faces challenges with resolving fonts.
        This is also not integrated with any plot-drawing library.
      </p>
      </li>
      <li>
        <p>
        It is apparently possible to use LaTeX in plot titles (at least)
        in the COMSOL software, though this is a commercial product 
        so I have not tried it myself.
        <!-- 
    Commercial product
    Using LaTeX to Add Mathematical Expressions to Plot Titles | COMSOL Blog
    https://www.comsol.com/blogs/using-latex-to-add-mathematical-expressions-to-plot-titles#:~:text=To%20add%20LaTeX%20commands%20in,for%20the%20display%20math%20mode
        -->
      </p>
      </li>
    </ul>
    <h2>
      <a name="requirements">10. Technical requirements</a>
    </h2>
    <p>
    The examples and discussion in this report relate to 
    R version 4.4.2 and 'xdvir' version 0.1-2.
  </p>
    <p>
    This report was generated within a Docker container
    (see <a href="#Resources">Resources</a> section below).
  </p>
    <h2>
      <a name="Resources">11. Resources</a>
    </h2>
    <ul>
      <li>
      The <a href="xdvir.cml">raw source file</a> for this
      report, a <a href="xdvir.xml">valid XML</a>
      transformation of the source file, a <a href="xdvir.Rhtml">'knitr' document</a> generated from
      the XML file, 
      two <a href="toc.R">R</a> <a href="bib.R">files</a> and
      the <a href="xdvir.bib">bibtex file</a>
      that are used to generate the table of contents and reference sections,
      two <a href="common.xsl">XSL</a> <a href="knitr.xsl">files</a> and an 
      <a href="knit.R">R file</a> that are used to transform the XML to
      the 'knitr' document, and a <a href="Makefile">Makefile</a> that
      contains code for the other transformations and coordinates
      everything.  
      These materials are also available
      on <a href="https://github.com/pmur002/xdvir-report/releases/tag/v1">github</a>.
    </li>
      <li>
      This report was generated within a 
      <a href="https://www.docker.com/">Docker</a> container.
      The Docker command to build the report is included in the Makefile above.
      The Docker image for the container is available from
      <a href="https://hub.docker.com/r/pmur002/xdvir-report/">Docker Hub</a>;
      alternatively, the image can be rebuilt from its 
      <a href="Dockerfile">Dockerfile</a>.
    </li>
    </ul>
    <h2>How to cite this report</h2>
    <p>
    Murrell, P. (2025). "LaTeX Typesetting in R: The 'xdvir' Package" 
    Technical Report 2025-01, Department of Statistics, The University of Auckland. 
    Version 1.
    [ <a href="how-to-cite.bib">bib</a> |
      <a href="http://dx.doi.org/10.17608/k6.auckland.28544465">DOI</a> | 
      <a href="https://stattech.blogs.auckland.ac.nz/2025/03/06/2025-01-latex-typesetting-in-r/">http</a> ]
  </p>
    <h2>
      <a name="references">12. References</a>
    </h2>
    <ul style="list-style-type: none">
      <li>
        <a name="xdvir-pkg"/>
      </li>
      <li>
        <a name="murrell-pedersen-urbanek-glyphs-2023"/>
      </li>
      <li>
        <a name="freetype2"/>
      </li>
      <li>
        <a name="knuth1982dvitype"/>
      </li>
      <li>
        <a name="tantau2013tikz"/>
      </li>
      <li>
        <a name="fonttools2025ttx"/>
      </li>
      <li>
        <a name="pkg:ragg"/>
      </li>
      <li>
        <a name="murrell-dvir"/>
      </li>
      <li>
        <a name="murrell-dvir-luatex"/>
      </li>
      <li>
        <a name="murrell-dvir-tikz"/>
      </li>
    </ul>
    <hr/>
    <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="CC" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
  </body>
</html>
